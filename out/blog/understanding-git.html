<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="minimum-scale=1, initial-scale=1, width=device-width, shrink-to-fit=no, user-scalable=1, viewport-fit=cover"/><title>Understanding Git - Merge, Rebase &amp; Bisect</title><meta name="title" content="Understanding Git - Merge, Rebase &amp; Bisect"/><meta name="description" content="In any git workflow, branching and merging code is unavoidable. In this post we are having a not-so deeper look at the three important git commands viz. git-merge, git-rebase and git-bisect."/><meta name="og:type" content="article"/><meta name="og:url" content="/blog/understanding-git"/><meta name="og:title" content="Understanding Git - Merge, Rebase &amp; Bisect"/><meta name="og:description" content="In any git workflow, branching and merging code is unavoidable. In this post we are having a not-so deeper look at the three important git commands viz. git-merge, git-rebase and git-bisect."/><meta name="og:image" content="/banners/05.png"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:url" content="/blog/understanding-git"/><meta name="twitter:title" content="Understanding Git - Merge, Rebase &amp; Bisect"/><meta name="twitter:description" content="In any git workflow, branching and merging code is unavoidable. In this post we are having a not-so deeper look at the three important git commands viz. git-merge, git-rebase and git-bisect."/><meta name="twitter:image" content="/banners/05.png"/><meta name="twitter:site" content="@krishnaanaril"/><meta name="twitter:creator" content="@krishnaanaril"/><meta name="keywords" content="git, rebase, tutorial"/><meta name="og:article:published_time" content="2020-05-08T00:00:00.000Z"/><meta name="og:article:modified_time" content="2020-05-08T00:00:00.000Z"/><meta name="og:article:author" content="Krishna Mohan A M"/><meta name="og:article:section" content="tech"/><meta name="og:article:tag" content="git, rebase, tutorial"/><meta name="next-head-count" content="23"/><link href="https://unpkg.com/prism-themes@1.6.0/themes/prism-shades-of-purple.css" rel="stylesheet"/><link rel="preload" href="/_next/static/css/a02e1e35a45fb249.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a02e1e35a45fb249.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-2b80368ae5a19708.js" defer=""></script><script src="/_next/static/chunks/pages/_app-f2cdab4dc7a6a07f.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bid%5D-81125a7cf08c6412.js" defer=""></script><script src="/_next/static/e2gJ0TqUapMJdpLqV3NaP/_buildManifest.js" defer=""></script><script src="/_next/static/e2gJ0TqUapMJdpLqV3NaP/_ssgManifest.js" defer=""></script></head><body class="bg-gray-200 text-gray-800 dark:bg-gray-800 dark:text-gray-50 px-5 lg:px-0"><div id="__next"><div><nav class="sticky top-0 bg-gray-200 text-gray-800 dark:bg-gray-800 dark:text-gray-50 bg-opacity-50 dark:bg-opacity-50 backdrop-blur-lg"><section class="hidden lg:flex flex-row justify-center"><nav><ul class="lg:text-xl lg:flex lg:flex-row"><li class=""><a class="block p-4 cursor-pointer" href="/">Home</a></li><li class="border-b-2 border-gray-700 dark:border-gray-300"><a class="block p-4 cursor-pointer" href="/blogs">Blog</a></li><li class=""><a class="block p-4 cursor-pointer" href="/projects">Projects</a></li><li class=""><a class="block p-4 cursor-pointer" href="/about">About</a></li></ul></nav></section><div class="lg:hidden mr-4 py-4 right-0"><button class="p-2" aria-label="view menu items"><svg class="fill-gray-800 dark:fill-gray-50" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="black" width="24px" height="24px"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"></path></svg></button></div></nav><div style="display:none" class="fixed top-0 left-0 bg-gray-200 text-gray-800 dark:bg-gray-800 dark:text-gray-50 bg-opacity-50 dark:bg-opacity-50 backdrop-blur-lg block h-screen lg:hidden p-2 w-screen z-1"><div class="bg-gray-100 bg-opacity-100 m-5 p-5 rounded-lg shadow-xl dark:bg-gray-600 dark:text-gray-50"><div class="flex flex-row justify-end"><button class="dark:text-gray-50" aria-label="close menu items"><svg class="fill-current" xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24"><path d="M0 0h24v24H0z" fill="none"></path><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path></svg></button></div><ul class="list-none"><li class=""><a class="block p-4 cursor-pointer" href="/">Home</a></li><li class="border-b-2 border-gray-700 dark:border-gray-300"><a class="block p-4 cursor-pointer" href="/blogs">Blog</a></li><li class=""><a class="block p-4 cursor-pointer" href="/projects">Projects</a></li><li class=""><a class="block p-4 cursor-pointer" href="/about">About</a></li></ul></div></div><div class="min-h-screen"><article class="bg-gray-200 text-gray-800 dark:bg-gray-800 dark:text-gray-50"><div><div aria-label="Blog tags/keywords" class="pt-8 flex flex-row justify-center"><div class="bg-gray-300 dark:bg-gray-700 border border-gray-400 ml-2 mr-2 pb-2 pl-4 pr-4 pt-2 text-sm align-baseline rounded-full">git</div><div class="bg-gray-300 dark:bg-gray-700 border border-gray-400 ml-2 mr-2 pb-2 pl-4 pr-4 pt-2 text-sm align-baseline rounded-full">rebase</div><div class="bg-gray-300 dark:bg-gray-700 border border-gray-400 ml-2 mr-2 pb-2 pl-4 pr-4 pt-2 text-sm align-baseline rounded-full">tutorial</div></div><div class="max-w-screen-lg mx-auto"><h1 class="text-5xl font-bold pt-5 pb-5 text-center">Understanding Git - Merge, Rebase &amp; Bisect</h1></div><div class="flex flex-row justify-center m-5 max-w-screen-sm mx-auto"><time class="text-center text-xl">8 May 2020</time></div></div><div class="prose dark:prose-invert lg:prose-xl md:prose-lg max-w-screen-md mx-auto"><p>In any git workflow, branching and merging code is unavoidable. Here we are having a not-so deeper look at the three important git commands viz. <a href="https://git-scm.com/docs/git-merge">git-merge</a>, <a href="https://git-scm.com/docs/git-rebase">git-rebase</a> and <a href="https://git-scm.com/docs/git-bisect">git-bisect</a>. At the end you’ll get an idea why certain options and sub-commands exist and its use cases. You can then adapt it to suit your needs.</p>
<h2>Git Merge</h2>
<p>As the name suggests this command will incorporate changes from named commits/branches to the current branch. <code>git merge topic</code> command will merge topic branch to the current branch. Here topic branch’s <code>HEAD</code> is considered for merge. One thing to note is that, before merge you should commit or stash your uncommitted local changes to avoid confusions during conflict resolution. Also if there are uncommitted changes, <code>git merge --abort</code> in some cases find it difficult to construct the pre-merge state.</p>
<p>Git merges can be broadly classified into two:</p>
<ol>
<li><strong>Fast Forward Merge</strong>: If there are no changes in the target branch, then source branch is merged without an extra commit.</li>
</ol>
<p><img src="/images/04_02.jpeg" alt="image">
<em>Fig-01</em></p>
<ol start="2">
<li><strong>True Merge</strong>: If there are changes in source and target branch, then an extra commit is required with both of them as parents.</li>
</ol>
<p><img src="/images/04_01.jpeg" alt="image">
<em>Fig-02</em></p>
<p>If there are conflicts in files during merge, we need to manually resolve it. Git will mark conflicts in the <a href="https://stackoverflow.com/questions/39128500/working-tree-vs-working-directory">working tree</a>. We should edit the files and stage them. Run <code>git commit</code> or <code>git merge —-continue</code> to complete the merge.</p>
<p>If you want to drop the merge, then run <code>git merge —-abort</code> or <code>git merge — -quit</code>. The difference between abort and quit is that, abort stops the current merge process and try to reconstruct the pre-merge state while quit leave the index and working-tree as is.</p>
<p>You can also merge multiple branches as <code>git merge branch1 branch2</code>. The strategy used for this type of merging is <strong><a href="https://git-scm.com/docs/merge-strategies#Documentation/merge-strategies.txt-octopus">Octopus</a></strong> strategy and it refuses to do a complex merge that needs manual resolution. So you should make sure that branches in octopus merge touch different files. You can find the different merging strategies <a href="https://git-scm.com/docs/merge-strategies">here</a>.</p>
<p>Want merge changes without a commit? Then use <code>git merge branch1 --squash</code>. This will merge the changes in ‘branch1’ to current branch without any merge information or commit. <code>git log</code> output will look like as if nothing happened.<code>--commit</code> flag is not allowed with this command and will fail.</p>
<h2>Git Rebase</h2>
<p>Rebase too helps in merging branches, but in a different way. Consider <code>git rebase master feature</code> command (short hand for <code>git switch feature</code>, <code>git rebase master</code>), here first all changes in the feature branch will be saved to a temporary area, then feature branch is reset to master branch and saved commits will be replayed one by one on top of it.</p>
<p><img src="/images/04_03.jpeg" alt="image">
<em>Fig-03</em></p>
<p>In case of conflict, rebasing process will be paused and we need to manually fix the conflicts. Once done you can run <code>git rebase --continue</code> to continue the process. To skip a commit, use <code>git rebase --skip</code>. In normal rebasing if the target branch contains merged commits, it will be dropped. We need to pass the option <code>--rebase-merges</code> to avoid this.</p>
<p><img src="/images/04_04.jpeg" alt="image">
<em>Fig-04</em></p>
<p>One of the powerful option in <code>git rebase</code> is interactive rebasing. It helps user to edit the commits, reorder or even remove them. There are 11 sub-commands that can be used with interactive rebasing, let’s see them one by one. For the purpose of explaining this consider the following branch with a linear history.</p>
<p><img src="/images/04_05.jpeg" alt="image">
<em>Fig-05</em></p>
<p>When i run <code>git rebase -i --root</code>, git will open text editor with commits and hints for using sub-commands. Each line will be in the following format: <code>sub-command commit-hash commit-message</code></p>
<ol>
<li><strong>pick</strong> - this command tells git to use this commit without any modification. e.g: <code>pick 9fadd5a add C</code></li>
<li><strong>drop</strong> - to drop the commit. All the changes associated with this commit will be dropped. e.g: <code>drop 9fadd5a add C</code></li>
<li><strong>reword</strong> - this command helps us to change the commit message. During rebasing when this command comes git will open the text editor to enter the new message. Once we enter the new message and saves it rebasing resumes automatically. e.g: <code>reword 9fadd5a add C</code></li>
<li><strong>squash</strong> - this command helps us to merge the current commit with the previous commit by preserving the commit message. The below command will result in a new commit with message <code>add C add D.</code></li>
</ol>
<div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">pick 9fadd5a add C
squash b390979 add D</code></pre></div>
<ol start="5">
<li><strong>fixup</strong> - this is similar to ‘squash’, but discard the commit message. The below command will result in a new commit with message <code>add C</code>.</li>
</ol>
<div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">pick 9fadd5a add C
fixup b390979 add D</code></pre></div>
<ol start="6">
<li><strong>edit</strong> - Consider the scenario, you’ve missed a file during the commit. If it was the last commit we can use <code>git commit --amend</code>, otherwise we’ll use interactive rebase with <code>edit</code>. First we’ll stash the files to be committed, then do a rebase and mark the commit to be edited using edit. e.g: <code>edit 9fadd5a add C</code>. Rebasing halts when it reaches edit command. Here we can pop the stashed changes and run <code>git commit --amend</code> to add the missed files. Once done you can run <code>git rebase --continue</code> to continue rebasing.</li>
<li><strong>exec</strong> - this command helps us to run a command or script. e.g: <code>exec ‘pwd’</code> will print current working directory during rebasing. This is just dumb example, but the command is really helpful in complex use cases.
eg: <strong>exec 'pwd'</strong> will print current working directory during rebasing. This is just dumb example, but really helpful in complex use cases.</li>
<li><strong>break</strong> - this command helps us to halt rebasing. To continue from here use <code>git rebase --continue</code>. e.g: <code>break</code> (in a single line)</li>
</ol>
<p>The remaining three commands are usually used together to replay merge commits. The commands are:</p>
<ol start="9">
<li><strong>label</strong> - this command helps us to provide an alternate name to the current HEAD.</li>
<li><strong>reset</strong> - this command helps us to reset current HEAD to the given label.</li>
<li><strong>merge</strong> - this command helps us to create a merge commit, if an original merge commit is provided, its message will be used otherwise we can provide a new one after '#'</li>
</ol>
<p>Here in this example, I’ll be using these commands to create a pseudo-merge commit from the linear git history (shown in the above figure)</p>
<div class="remark-highlight"><pre class="language-bash"><code class="language-bash">pick 9fadd5a <span class="token function">add</span> A
label onto

pick b390979 <span class="token function">add</span> B
pick 97fabfa <span class="token function">add</span> C
label main

reset onto
pick 4ecb083 <span class="token function">add</span> D
pick a9f32a0 <span class="token function">add</span> E
label sub

reset main
merge sub <span class="token comment"># This is new merge commit</span>
</code></pre></div>
<p>Here we are labeling commits A, C &#x26; E as ‘onto’, ‘main’ and ‘sub’ respectively. Final result will be as below. You can find another great read <a href="https://stackoverflow.com/a/61103385/1520750">here</a></p>
<p><img src="/images/04_06.jpeg" alt="image">
<em>Fig-06</em></p>
<h2>Git Bisect</h2>
<p>This is another git command with a bunch of sub commands. It helps to find the commit that introduced a bug/change by <strong>binary search</strong>. First you need to mark at least two commits as good and bad respectively, so that git can do the binary search.
eg:</p>
<div class="remark-highlight"><pre class="language-bash"><code class="language-bash"><span class="token function">git</span> bisect start
<span class="token function">git</span> bisect bad 4ecb083
<span class="token function">git</span> bisect good 97fabfa
</code></pre></div>
<p>Short hand for the above is <code>git bisect start [bad commit] [good commit]</code></p>
<div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">git bisect start 4ecb083 97fabfa</code></pre></div>
<p>Once done git will pick a commit in between good and bad and ask us whether it is either good or bad. We need to check and mark appropriately. To mark good run the command <code>git bisect good</code> otherwise <code>git bisect bad</code>. This process continues until git finds the first bad commit. To reset back to previous state run <code>git bisect reset</code>, if you want to switch to a specific commit run <code>git bisect reset commithash</code>. To go back to bad commit when bisect is completed, use the command <code>git bisect reset bisect/bad</code>. ‘bisect/bad’ is a single option and should be used together. I used it as <code>git bisect reset bad</code> the first time and got error. 😃</p>
<p>But don’t you find this bit boring? Can we automate this? 🤔</p>
<p>Of course yes! If you have an external test script you can run it as below. One catch is that your tests and test script should be in an external path or untracked in the current repository.</p>
<div class="remark-highlight"><pre class="language-bash"><code class="language-bash"><span class="token function">git</span> bisect start <span class="token variable">$badCommit</span> <span class="token variable">$goodCommit</span>
<span class="token function">git</span> bisect run <span class="token variable">$testScript</span>
<span class="token function">git</span> bisect reset <span class="token comment"># go back to previous state after bisect</span>
</code></pre></div>
<p>An example power-shell script to run dotnet tests is given below.</p>
<div class="remark-highlight"><pre class="language-ps"><code class="language-ps"> param (
    [Parameter(Mandatory=$true)]
    [string]$goodCommit = $( Read-Host &#x26;quot;Good commit hash, please&#x26;quot; ),
    [Parameter(Mandatory=$true)]
    [string]$badCommit = $( Read-Host &#x26;quot;Bad commit hash, please&#x26;quot; ),
    [Parameter(Mandatory=$true)]
    [string]$testProjectPath = $( Read-Host &#x26;quot;Test project path, please&#x26;quot; )
 )
 Write-Host $goodCommit $badCommit $testProjectPath 
 try 
 {
   git bisect start $badCommit $goodCommit
   git bisect run dotnet test $testProjectPath -v q
   git bisect reset
 }
 catch {
    write-host &#x26;quot;Caught an exception:&#x26;quot; -ForegroundColor Red
    write-host &#x26;quot;Exception Type: $($_.Exception.GetType().FullName)&#x26;quot; -ForegroundColor Red
    write-host &#x26;quot;Exception Message: $($_.Exception.Message)&#x26;quot; -ForegroundColor Red
}</code></pre></div>
<p>If you discover that you made a mistake in specifying the status of a revision, you can save the output of <code>git bisect log</code> to a file. Edit it to remove the incorrect entries, and then issue the following commands to return to a corrected state.</p>
<div class="remark-highlight"><pre class="language-bash"><code class="language-bash"><span class="token function">git</span> bisect log <span class="token operator">></span> log-file
<span class="token function">git</span> bisect reset
<span class="token function">git</span> bisect replay log-file
</code></pre></div>
<p>Woof, That's some long read.</p>
</div></article></div><footer class="flex flex-col bg-gray-200 text-gray-800 dark:bg-gray-800 dark:text-gray-50"><div class="mt-10"><ul class="flex flex-row justify-between max-w-sm mx-auto pl-4 pr-4"><li class="hover:text-gray-600 dark:hover:text-gray-100"><a href="https://twitter.com/KrishnaAnaril">Twitter</a></li><li><a href="https://krishnamohan.dev/sitemap.xml">Sitemap</a></li><li><a href="https://krishnamohan.dev/rss.xml">RSS</a></li><li><a href="mailto:krishnamohan.a.m@gmail.com">Contact</a></li></ul></div><div class="mx-auto p-5 text-sm"><p>© 2021-present <a class="font-bold" href="https://krishnamohan.dev/">Krishna Mohan A M</a>. All Rights Reserved.</p></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"id":"understanding-git","meta":{"title":"Understanding Git - Merge, Rebase \u0026 Bisect","description":"In any git workflow, branching and merging code is unavoidable. In this post we are having a not-so deeper look at the three important git commands viz. git-merge, git-rebase and git-bisect.","published":true,"publishedAt":"2020-05-08T00:00:00.000Z","updatedAt":"2020-05-08T00:00:00.000Z","category":"tech","image":"banners/05","keywords":["git","rebase","tutorial"],"authors":["Krishna Mohan A M"]},"content":"\u003cp\u003eIn any git workflow, branching and merging code is unavoidable. Here we are having a not-so deeper look at the three important git commands viz. \u003ca href=\"https://git-scm.com/docs/git-merge\"\u003egit-merge\u003c/a\u003e, \u003ca href=\"https://git-scm.com/docs/git-rebase\"\u003egit-rebase\u003c/a\u003e and \u003ca href=\"https://git-scm.com/docs/git-bisect\"\u003egit-bisect\u003c/a\u003e. At the end you’ll get an idea why certain options and sub-commands exist and its use cases. You can then adapt it to suit your needs.\u003c/p\u003e\n\u003ch2\u003eGit Merge\u003c/h2\u003e\n\u003cp\u003eAs the name suggests this command will incorporate changes from named commits/branches to the current branch. \u003ccode\u003egit merge topic\u003c/code\u003e command will merge topic branch to the current branch. Here topic branch’s \u003ccode\u003eHEAD\u003c/code\u003e is considered for merge. One thing to note is that, before merge you should commit or stash your uncommitted local changes to avoid confusions during conflict resolution. Also if there are uncommitted changes, \u003ccode\u003egit merge --abort\u003c/code\u003e in some cases find it difficult to construct the pre-merge state.\u003c/p\u003e\n\u003cp\u003eGit merges can be broadly classified into two:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eFast Forward Merge\u003c/strong\u003e: If there are no changes in the target branch, then source branch is merged without an extra commit.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg src=\"/images/04_02.jpeg\" alt=\"image\"\u003e\r\n\u003cem\u003eFig-01\u003c/em\u003e\u003c/p\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e\u003cstrong\u003eTrue Merge\u003c/strong\u003e: If there are changes in source and target branch, then an extra commit is required with both of them as parents.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg src=\"/images/04_01.jpeg\" alt=\"image\"\u003e\r\n\u003cem\u003eFig-02\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eIf there are conflicts in files during merge, we need to manually resolve it. Git will mark conflicts in the \u003ca href=\"https://stackoverflow.com/questions/39128500/working-tree-vs-working-directory\"\u003eworking tree\u003c/a\u003e. We should edit the files and stage them. Run \u003ccode\u003egit commit\u003c/code\u003e or \u003ccode\u003egit merge —-continue\u003c/code\u003e to complete the merge.\u003c/p\u003e\n\u003cp\u003eIf you want to drop the merge, then run \u003ccode\u003egit merge —-abort\u003c/code\u003e or \u003ccode\u003egit merge — -quit\u003c/code\u003e. The difference between abort and quit is that, abort stops the current merge process and try to reconstruct the pre-merge state while quit leave the index and working-tree as is.\u003c/p\u003e\n\u003cp\u003eYou can also merge multiple branches as \u003ccode\u003egit merge branch1 branch2\u003c/code\u003e. The strategy used for this type of merging is \u003cstrong\u003e\u003ca href=\"https://git-scm.com/docs/merge-strategies#Documentation/merge-strategies.txt-octopus\"\u003eOctopus\u003c/a\u003e\u003c/strong\u003e strategy and it refuses to do a complex merge that needs manual resolution. So you should make sure that branches in octopus merge touch different files. You can find the different merging strategies \u003ca href=\"https://git-scm.com/docs/merge-strategies\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eWant merge changes without a commit? Then use \u003ccode\u003egit merge branch1 --squash\u003c/code\u003e. This will merge the changes in ‘branch1’ to current branch without any merge information or commit. \u003ccode\u003egit log\u003c/code\u003e output will look like as if nothing happened.\u003ccode\u003e--commit\u003c/code\u003e flag is not allowed with this command and will fail.\u003c/p\u003e\n\u003ch2\u003eGit Rebase\u003c/h2\u003e\n\u003cp\u003eRebase too helps in merging branches, but in a different way. Consider \u003ccode\u003egit rebase master feature\u003c/code\u003e command (short hand for \u003ccode\u003egit switch feature\u003c/code\u003e, \u003ccode\u003egit rebase master\u003c/code\u003e), here first all changes in the feature branch will be saved to a temporary area, then feature branch is reset to master branch and saved commits will be replayed one by one on top of it.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/04_03.jpeg\" alt=\"image\"\u003e\r\n\u003cem\u003eFig-03\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eIn case of conflict, rebasing process will be paused and we need to manually fix the conflicts. Once done you can run \u003ccode\u003egit rebase --continue\u003c/code\u003e to continue the process. To skip a commit, use \u003ccode\u003egit rebase --skip\u003c/code\u003e. In normal rebasing if the target branch contains merged commits, it will be dropped. We need to pass the option \u003ccode\u003e--rebase-merges\u003c/code\u003e to avoid this.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/04_04.jpeg\" alt=\"image\"\u003e\r\n\u003cem\u003eFig-04\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eOne of the powerful option in \u003ccode\u003egit rebase\u003c/code\u003e is interactive rebasing. It helps user to edit the commits, reorder or even remove them. There are 11 sub-commands that can be used with interactive rebasing, let’s see them one by one. For the purpose of explaining this consider the following branch with a linear history.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/04_05.jpeg\" alt=\"image\"\u003e\r\n\u003cem\u003eFig-05\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eWhen i run \u003ccode\u003egit rebase -i --root\u003c/code\u003e, git will open text editor with commits and hints for using sub-commands. Each line will be in the following format: \u003ccode\u003esub-command commit-hash commit-message\u003c/code\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003epick\u003c/strong\u003e - this command tells git to use this commit without any modification. e.g: \u003ccode\u003epick 9fadd5a add C\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003edrop\u003c/strong\u003e - to drop the commit. All the changes associated with this commit will be dropped. e.g: \u003ccode\u003edrop 9fadd5a add C\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ereword\u003c/strong\u003e - this command helps us to change the commit message. During rebasing when this command comes git will open the text editor to enter the new message. Once we enter the new message and saves it rebasing resumes automatically. e.g: \u003ccode\u003ereword 9fadd5a add C\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003esquash\u003c/strong\u003e - this command helps us to merge the current commit with the previous commit by preserving the commit message. The below command will result in a new commit with message \u003ccode\u003eadd C add D.\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre class=\"language-unknown\"\u003e\u003ccode class=\"language-unknown\"\u003epick 9fadd5a add C\r\nsquash b390979 add D\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003col start=\"5\"\u003e\n\u003cli\u003e\u003cstrong\u003efixup\u003c/strong\u003e - this is similar to ‘squash’, but discard the commit message. The below command will result in a new commit with message \u003ccode\u003eadd C\u003c/code\u003e.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre class=\"language-unknown\"\u003e\u003ccode class=\"language-unknown\"\u003epick 9fadd5a add C\r\nfixup b390979 add D\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003col start=\"6\"\u003e\n\u003cli\u003e\u003cstrong\u003eedit\u003c/strong\u003e - Consider the scenario, you’ve missed a file during the commit. If it was the last commit we can use \u003ccode\u003egit commit --amend\u003c/code\u003e, otherwise we’ll use interactive rebase with \u003ccode\u003eedit\u003c/code\u003e. First we’ll stash the files to be committed, then do a rebase and mark the commit to be edited using edit. e.g: \u003ccode\u003eedit 9fadd5a add C\u003c/code\u003e. Rebasing halts when it reaches edit command. Here we can pop the stashed changes and run \u003ccode\u003egit commit --amend\u003c/code\u003e to add the missed files. Once done you can run \u003ccode\u003egit rebase --continue\u003c/code\u003e to continue rebasing.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eexec\u003c/strong\u003e - this command helps us to run a command or script. e.g: \u003ccode\u003eexec ‘pwd’\u003c/code\u003e will print current working directory during rebasing. This is just dumb example, but the command is really helpful in complex use cases.\r\neg: \u003cstrong\u003eexec 'pwd'\u003c/strong\u003e will print current working directory during rebasing. This is just dumb example, but really helpful in complex use cases.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ebreak\u003c/strong\u003e - this command helps us to halt rebasing. To continue from here use \u003ccode\u003egit rebase --continue\u003c/code\u003e. e.g: \u003ccode\u003ebreak\u003c/code\u003e (in a single line)\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThe remaining three commands are usually used together to replay merge commits. The commands are:\u003c/p\u003e\n\u003col start=\"9\"\u003e\n\u003cli\u003e\u003cstrong\u003elabel\u003c/strong\u003e - this command helps us to provide an alternate name to the current HEAD.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ereset\u003c/strong\u003e - this command helps us to reset current HEAD to the given label.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003emerge\u003c/strong\u003e - this command helps us to create a merge commit, if an original merge commit is provided, its message will be used otherwise we can provide a new one after '#'\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eHere in this example, I’ll be using these commands to create a pseudo-merge commit from the linear git history (shown in the above figure)\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre class=\"language-bash\"\u003e\u003ccode class=\"language-bash\"\u003epick 9fadd5a \u003cspan class=\"token function\"\u003eadd\u003c/span\u003e A\nlabel onto\n\npick b390979 \u003cspan class=\"token function\"\u003eadd\u003c/span\u003e B\npick 97fabfa \u003cspan class=\"token function\"\u003eadd\u003c/span\u003e C\nlabel main\n\nreset onto\npick 4ecb083 \u003cspan class=\"token function\"\u003eadd\u003c/span\u003e D\npick a9f32a0 \u003cspan class=\"token function\"\u003eadd\u003c/span\u003e E\nlabel sub\n\nreset main\nmerge sub \u003cspan class=\"token comment\"\u003e# This is new merge commit\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eHere we are labeling commits A, C \u0026#x26; E as ‘onto’, ‘main’ and ‘sub’ respectively. Final result will be as below. You can find another great read \u003ca href=\"https://stackoverflow.com/a/61103385/1520750\"\u003ehere\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/04_06.jpeg\" alt=\"image\"\u003e\r\n\u003cem\u003eFig-06\u003c/em\u003e\u003c/p\u003e\n\u003ch2\u003eGit Bisect\u003c/h2\u003e\n\u003cp\u003eThis is another git command with a bunch of sub commands. It helps to find the commit that introduced a bug/change by \u003cstrong\u003ebinary search\u003c/strong\u003e. First you need to mark at least two commits as good and bad respectively, so that git can do the binary search.\r\neg:\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre class=\"language-bash\"\u003e\u003ccode class=\"language-bash\"\u003e\u003cspan class=\"token function\"\u003egit\u003c/span\u003e bisect start\n\u003cspan class=\"token function\"\u003egit\u003c/span\u003e bisect bad 4ecb083\n\u003cspan class=\"token function\"\u003egit\u003c/span\u003e bisect good 97fabfa\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eShort hand for the above is \u003ccode\u003egit bisect start [bad commit] [good commit]\u003c/code\u003e\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre class=\"language-unknown\"\u003e\u003ccode class=\"language-unknown\"\u003egit bisect start 4ecb083 97fabfa\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eOnce done git will pick a commit in between good and bad and ask us whether it is either good or bad. We need to check and mark appropriately. To mark good run the command \u003ccode\u003egit bisect good\u003c/code\u003e otherwise \u003ccode\u003egit bisect bad\u003c/code\u003e. This process continues until git finds the first bad commit. To reset back to previous state run \u003ccode\u003egit bisect reset\u003c/code\u003e, if you want to switch to a specific commit run \u003ccode\u003egit bisect reset commithash\u003c/code\u003e. To go back to bad commit when bisect is completed, use the command \u003ccode\u003egit bisect reset bisect/bad\u003c/code\u003e. ‘bisect/bad’ is a single option and should be used together. I used it as \u003ccode\u003egit bisect reset bad\u003c/code\u003e the first time and got error. 😃\u003c/p\u003e\n\u003cp\u003eBut don’t you find this bit boring? Can we automate this? 🤔\u003c/p\u003e\n\u003cp\u003eOf course yes! If you have an external test script you can run it as below. One catch is that your tests and test script should be in an external path or untracked in the current repository.\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre class=\"language-bash\"\u003e\u003ccode class=\"language-bash\"\u003e\u003cspan class=\"token function\"\u003egit\u003c/span\u003e bisect start \u003cspan class=\"token variable\"\u003e$badCommit\u003c/span\u003e \u003cspan class=\"token variable\"\u003e$goodCommit\u003c/span\u003e\n\u003cspan class=\"token function\"\u003egit\u003c/span\u003e bisect run \u003cspan class=\"token variable\"\u003e$testScript\u003c/span\u003e\n\u003cspan class=\"token function\"\u003egit\u003c/span\u003e bisect reset \u003cspan class=\"token comment\"\u003e# go back to previous state after bisect\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eAn example power-shell script to run dotnet tests is given below.\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre class=\"language-ps\"\u003e\u003ccode class=\"language-ps\"\u003e param (\r\n    [Parameter(Mandatory=$true)]\r\n    [string]$goodCommit = $( Read-Host \u0026#x26;quot;Good commit hash, please\u0026#x26;quot; ),\r\n    [Parameter(Mandatory=$true)]\r\n    [string]$badCommit = $( Read-Host \u0026#x26;quot;Bad commit hash, please\u0026#x26;quot; ),\r\n    [Parameter(Mandatory=$true)]\r\n    [string]$testProjectPath = $( Read-Host \u0026#x26;quot;Test project path, please\u0026#x26;quot; )\r\n )\r\n Write-Host $goodCommit $badCommit $testProjectPath \r\n try \r\n {\r\n   git bisect start $badCommit $goodCommit\r\n   git bisect run dotnet test $testProjectPath -v q\r\n   git bisect reset\r\n }\r\n catch {\r\n    write-host \u0026#x26;quot;Caught an exception:\u0026#x26;quot; -ForegroundColor Red\r\n    write-host \u0026#x26;quot;Exception Type: $($_.Exception.GetType().FullName)\u0026#x26;quot; -ForegroundColor Red\r\n    write-host \u0026#x26;quot;Exception Message: $($_.Exception.Message)\u0026#x26;quot; -ForegroundColor Red\r\n}\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eIf you discover that you made a mistake in specifying the status of a revision, you can save the output of \u003ccode\u003egit bisect log\u003c/code\u003e to a file. Edit it to remove the incorrect entries, and then issue the following commands to return to a corrected state.\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre class=\"language-bash\"\u003e\u003ccode class=\"language-bash\"\u003e\u003cspan class=\"token function\"\u003egit\u003c/span\u003e bisect log \u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e log-file\n\u003cspan class=\"token function\"\u003egit\u003c/span\u003e bisect reset\n\u003cspan class=\"token function\"\u003egit\u003c/span\u003e bisect replay log-file\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eWoof, That's some long read.\u003c/p\u003e\n"},"__N_SSG":true},"page":"/blog/[id]","query":{"id":"understanding-git"},"buildId":"e2gJ0TqUapMJdpLqV3NaP","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>