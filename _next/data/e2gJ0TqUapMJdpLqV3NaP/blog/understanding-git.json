{"pageProps":{"id":"understanding-git","meta":{"title":"Understanding Git - Merge, Rebase & Bisect","description":"In any git workflow, branching and merging code is unavoidable. In this post we are having a not-so deeper look at the three important git commands viz. git-merge, git-rebase and git-bisect.","published":true,"publishedAt":"2020-05-08T00:00:00.000Z","updatedAt":"2020-05-08T00:00:00.000Z","category":"tech","image":"banners/05","keywords":["git","rebase","tutorial"],"authors":["Krishna Mohan A M"]},"content":"<p>In any git workflow, branching and merging code is unavoidable. Here we are having a not-so deeper look at the three important git commands viz. <a href=\"https://git-scm.com/docs/git-merge\">git-merge</a>, <a href=\"https://git-scm.com/docs/git-rebase\">git-rebase</a> and <a href=\"https://git-scm.com/docs/git-bisect\">git-bisect</a>. At the end youâ€™ll get an idea why certain options and sub-commands exist and its use cases. You can then adapt it to suit your needs.</p>\n<h2>Git Merge</h2>\n<p>As the name suggests this command will incorporate changes from named commits/branches to the current branch. <code>git merge topic</code> command will merge topic branch to the current branch. Here topic branchâ€™s <code>HEAD</code> is considered for merge. One thing to note is that, before merge you should commit or stash your uncommitted local changes to avoid confusions during conflict resolution. Also if there are uncommitted changes, <code>git merge --abort</code> in some cases find it difficult to construct the pre-merge state.</p>\n<p>Git merges can be broadly classified into two:</p>\n<ol>\n<li><strong>Fast Forward Merge</strong>: If there are no changes in the target branch, then source branch is merged without an extra commit.</li>\n</ol>\n<p><img src=\"/images/04_02.jpeg\" alt=\"image\">\r\n<em>Fig-01</em></p>\n<ol start=\"2\">\n<li><strong>True Merge</strong>: If there are changes in source and target branch, then an extra commit is required with both of them as parents.</li>\n</ol>\n<p><img src=\"/images/04_01.jpeg\" alt=\"image\">\r\n<em>Fig-02</em></p>\n<p>If there are conflicts in files during merge, we need to manually resolve it. Git will mark conflicts in the <a href=\"https://stackoverflow.com/questions/39128500/working-tree-vs-working-directory\">working tree</a>. We should edit the files and stage them. Run <code>git commit</code> or <code>git merge â€”-continue</code> to complete the merge.</p>\n<p>If you want to drop the merge, then run <code>git merge â€”-abort</code> or <code>git merge â€” -quit</code>. The difference between abort and quit is that, abort stops the current merge process and try to reconstruct the pre-merge state while quit leave the index and working-tree as is.</p>\n<p>You can also merge multiple branches as <code>git merge branch1 branch2</code>. The strategy used for this type of merging is <strong><a href=\"https://git-scm.com/docs/merge-strategies#Documentation/merge-strategies.txt-octopus\">Octopus</a></strong> strategy and it refuses to do a complex merge that needs manual resolution. So you should make sure that branches in octopus merge touch different files. You can find the different merging strategies <a href=\"https://git-scm.com/docs/merge-strategies\">here</a>.</p>\n<p>Want merge changes without a commit? Then use <code>git merge branch1 --squash</code>. This will merge the changes in â€˜branch1â€™ to current branch without any merge information or commit. <code>git log</code> output will look like as if nothing happened.<code>--commit</code> flag is not allowed with this command and will fail.</p>\n<h2>Git Rebase</h2>\n<p>Rebase too helps in merging branches, but in a different way. Consider <code>git rebase master feature</code> command (short hand for <code>git switch feature</code>, <code>git rebase master</code>), here first all changes in the feature branch will be saved to a temporary area, then feature branch is reset to master branch and saved commits will be replayed one by one on top of it.</p>\n<p><img src=\"/images/04_03.jpeg\" alt=\"image\">\r\n<em>Fig-03</em></p>\n<p>In case of conflict, rebasing process will be paused and we need to manually fix the conflicts. Once done you can run <code>git rebase --continue</code> to continue the process. To skip a commit, use <code>git rebase --skip</code>. In normal rebasing if the target branch contains merged commits, it will be dropped. We need to pass the option <code>--rebase-merges</code> to avoid this.</p>\n<p><img src=\"/images/04_04.jpeg\" alt=\"image\">\r\n<em>Fig-04</em></p>\n<p>One of the powerful option in <code>git rebase</code> is interactive rebasing. It helps user to edit the commits, reorder or even remove them. There are 11 sub-commands that can be used with interactive rebasing, letâ€™s see them one by one. For the purpose of explaining this consider the following branch with a linear history.</p>\n<p><img src=\"/images/04_05.jpeg\" alt=\"image\">\r\n<em>Fig-05</em></p>\n<p>When i run <code>git rebase -i --root</code>, git will open text editor with commits and hints for using sub-commands. Each line will be in the following format: <code>sub-command commit-hash commit-message</code></p>\n<ol>\n<li><strong>pick</strong> - this command tells git to use this commit without any modification. e.g: <code>pick 9fadd5a add C</code></li>\n<li><strong>drop</strong> - to drop the commit. All the changes associated with this commit will be dropped. e.g: <code>drop 9fadd5a add C</code></li>\n<li><strong>reword</strong> - this command helps us to change the commit message. During rebasing when this command comes git will open the text editor to enter the new message. Once we enter the new message and saves it rebasing resumes automatically. e.g: <code>reword 9fadd5a add C</code></li>\n<li><strong>squash</strong> - this command helps us to merge the current commit with the previous commit by preserving the commit message. The below command will result in a new commit with message <code>add C add D.</code></li>\n</ol>\n<div class=\"remark-highlight\"><pre class=\"language-unknown\"><code class=\"language-unknown\">pick 9fadd5a add C\r\nsquash b390979 add D</code></pre></div>\n<ol start=\"5\">\n<li><strong>fixup</strong> - this is similar to â€˜squashâ€™, but discard the commit message. The below command will result in a new commit with message <code>add C</code>.</li>\n</ol>\n<div class=\"remark-highlight\"><pre class=\"language-unknown\"><code class=\"language-unknown\">pick 9fadd5a add C\r\nfixup b390979 add D</code></pre></div>\n<ol start=\"6\">\n<li><strong>edit</strong> - Consider the scenario, youâ€™ve missed a file during the commit. If it was the last commit we can use <code>git commit --amend</code>, otherwise weâ€™ll use interactive rebase with <code>edit</code>. First weâ€™ll stash the files to be committed, then do a rebase and mark the commit to be edited using edit. e.g: <code>edit 9fadd5a add C</code>. Rebasing halts when it reaches edit command. Here we can pop the stashed changes and run <code>git commit --amend</code> to add the missed files. Once done you can run <code>git rebase --continue</code> to continue rebasing.</li>\n<li><strong>exec</strong> - this command helps us to run a command or script. e.g: <code>exec â€˜pwdâ€™</code> will print current working directory during rebasing. This is just dumb example, but the command is really helpful in complex use cases.\r\neg: <strong>exec 'pwd'</strong> will print current working directory during rebasing. This is just dumb example, but really helpful in complex use cases.</li>\n<li><strong>break</strong> - this command helps us to halt rebasing. To continue from here use <code>git rebase --continue</code>. e.g: <code>break</code> (in a single line)</li>\n</ol>\n<p>The remaining three commands are usually used together to replay merge commits. The commands are:</p>\n<ol start=\"9\">\n<li><strong>label</strong> - this command helps us to provide an alternate name to the current HEAD.</li>\n<li><strong>reset</strong> - this command helps us to reset current HEAD to the given label.</li>\n<li><strong>merge</strong> - this command helps us to create a merge commit, if an original merge commit is provided, its message will be used otherwise we can provide a new one after '#'</li>\n</ol>\n<p>Here in this example, Iâ€™ll be using these commands to create a pseudo-merge commit from the linear git history (shown in the above figure)</p>\n<div class=\"remark-highlight\"><pre class=\"language-bash\"><code class=\"language-bash\">pick 9fadd5a <span class=\"token function\">add</span> A\nlabel onto\n\npick b390979 <span class=\"token function\">add</span> B\npick 97fabfa <span class=\"token function\">add</span> C\nlabel main\n\nreset onto\npick 4ecb083 <span class=\"token function\">add</span> D\npick a9f32a0 <span class=\"token function\">add</span> E\nlabel sub\n\nreset main\nmerge sub <span class=\"token comment\"># This is new merge commit</span>\n</code></pre></div>\n<p>Here we are labeling commits A, C &#x26; E as â€˜ontoâ€™, â€˜mainâ€™ and â€˜subâ€™ respectively. Final result will be as below. You can find another great read <a href=\"https://stackoverflow.com/a/61103385/1520750\">here</a></p>\n<p><img src=\"/images/04_06.jpeg\" alt=\"image\">\r\n<em>Fig-06</em></p>\n<h2>Git Bisect</h2>\n<p>This is another git command with a bunch of sub commands. It helps to find the commit that introduced a bug/change by <strong>binary search</strong>. First you need to mark at least two commits as good and bad respectively, so that git can do the binary search.\r\neg:</p>\n<div class=\"remark-highlight\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> bisect start\n<span class=\"token function\">git</span> bisect bad 4ecb083\n<span class=\"token function\">git</span> bisect good 97fabfa\n</code></pre></div>\n<p>Short hand for the above is <code>git bisect start [bad commit] [good commit]</code></p>\n<div class=\"remark-highlight\"><pre class=\"language-unknown\"><code class=\"language-unknown\">git bisect start 4ecb083 97fabfa</code></pre></div>\n<p>Once done git will pick a commit in between good and bad and ask us whether it is either good or bad. We need to check and mark appropriately. To mark good run the command <code>git bisect good</code> otherwise <code>git bisect bad</code>. This process continues until git finds the first bad commit. To reset back to previous state run <code>git bisect reset</code>, if you want to switch to a specific commit run <code>git bisect reset commithash</code>. To go back to bad commit when bisect is completed, use the command <code>git bisect reset bisect/bad</code>. â€˜bisect/badâ€™ is a single option and should be used together. I used it as <code>git bisect reset bad</code> the first time and got error. ðŸ˜ƒ</p>\n<p>But donâ€™t you find this bit boring? Can we automate this? ðŸ¤”</p>\n<p>Of course yes! If you have an external test script you can run it as below. One catch is that your tests and test script should be in an external path or untracked in the current repository.</p>\n<div class=\"remark-highlight\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> bisect start <span class=\"token variable\">$badCommit</span> <span class=\"token variable\">$goodCommit</span>\n<span class=\"token function\">git</span> bisect run <span class=\"token variable\">$testScript</span>\n<span class=\"token function\">git</span> bisect reset <span class=\"token comment\"># go back to previous state after bisect</span>\n</code></pre></div>\n<p>An example power-shell script to run dotnet tests is given below.</p>\n<div class=\"remark-highlight\"><pre class=\"language-ps\"><code class=\"language-ps\"> param (\r\n    [Parameter(Mandatory=$true)]\r\n    [string]$goodCommit = $( Read-Host &#x26;quot;Good commit hash, please&#x26;quot; ),\r\n    [Parameter(Mandatory=$true)]\r\n    [string]$badCommit = $( Read-Host &#x26;quot;Bad commit hash, please&#x26;quot; ),\r\n    [Parameter(Mandatory=$true)]\r\n    [string]$testProjectPath = $( Read-Host &#x26;quot;Test project path, please&#x26;quot; )\r\n )\r\n Write-Host $goodCommit $badCommit $testProjectPath \r\n try \r\n {\r\n   git bisect start $badCommit $goodCommit\r\n   git bisect run dotnet test $testProjectPath -v q\r\n   git bisect reset\r\n }\r\n catch {\r\n    write-host &#x26;quot;Caught an exception:&#x26;quot; -ForegroundColor Red\r\n    write-host &#x26;quot;Exception Type: $($_.Exception.GetType().FullName)&#x26;quot; -ForegroundColor Red\r\n    write-host &#x26;quot;Exception Message: $($_.Exception.Message)&#x26;quot; -ForegroundColor Red\r\n}</code></pre></div>\n<p>If you discover that you made a mistake in specifying the status of a revision, you can save the output of <code>git bisect log</code> to a file. Edit it to remove the incorrect entries, and then issue the following commands to return to a corrected state.</p>\n<div class=\"remark-highlight\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> bisect log <span class=\"token operator\">></span> log-file\n<span class=\"token function\">git</span> bisect reset\n<span class=\"token function\">git</span> bisect replay log-file\n</code></pre></div>\n<p>Woof, That's some long read.</p>\n"},"__N_SSG":true}