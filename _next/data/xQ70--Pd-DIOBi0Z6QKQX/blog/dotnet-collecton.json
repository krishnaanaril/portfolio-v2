{"pageProps":{"id":"dotnet-collecton","meta":{"title":"Understanding the nuances of C# Collections","description":"This article is based on .NET 9 and C# 13. I aim to cover the behaviors of common collections within the `System.Collections.Generic` namespace.","published":true,"publishedAt":"2025-01-05T00:00:00.000Z","updatedAt":"2025-01-05T00:00:00.000Z","category":"tech","image":"banners/76","keywords":["dotnet","performance"],"authors":["Krishna Mohan A M"]},"content":"<p>This article is based on .NET 9 and C# 13. I aim to cover the behaviors of common collections within the <code>System.Collections.Generic</code> namespace.</p>\n<h2>Insertion behaviors in Dictionary</h2>\n<p>The <code>Dictionary&#x3C;TKey, TValue></code> provides a mapping from a set of keys to a set of values. Values can be inserted into a dictionary with varying behaviors. Insertion in a <code>Dictionary</code> is implemented by the private method <a href=\"https://github.com/dotnet/runtime/blob/1d1bf92fcf43aa6981804dc53c5174445069c9e4/src/libraries/System.Private.CoreLib/src/System/Collections/Generic/Dictionary.cs#L507\"><code>TryInsert</code></a>. This method accepts an additional parameter <code>behavior</code>, which is an enum with values <code>IgnoreInsertion</code>, <code>OverwriteExisting</code>, and <code>ThrowOnExisting</code>. Consider the following code, where each operation behaves differently:</p>\n<div class=\"remark-highlight\"><pre class=\"language-csharp\"><code class=\"language-csharp\"><span class=\"token class-name\">Dictionary<span class=\"token punctuation\">&#x3C;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">></span></span> dict <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token constructor-invocation class-name\">Dictionary<span class=\"token punctuation\">&#x3C;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ndict<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Calls underlying private method TryInsert with behavior OverwriteExisting</span>\nDebug<span class=\"token punctuation\">.</span><span class=\"token function\">Assert</span><span class=\"token punctuation\">(</span>dict<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ndict<span class=\"token punctuation\">.</span><span class=\"token function\">TryAdd</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Calls underlying private method TryInsert with behavior IgnoreInsertion</span>\nDebug<span class=\"token punctuation\">.</span><span class=\"token function\">Assert</span><span class=\"token punctuation\">(</span>dict<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ndict<span class=\"token punctuation\">.</span><span class=\"token function\">Add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// Calls underlying private method TryInsert with behavior ThrowOnExisting</span>\n</code></pre></div>\n<h2>The Curious case of 'Capacity' and 'Count'</h2>\n<p>The <code>Dictionary</code> also exposes two properties: <code>Count</code> and Capac<code>ity. </code>Count<code>denotes the number of key-value pairs in the dictionary, and</code>Capacity<code>denotes the size of the underlying container that holds the dictionary. The</code>Capacity<code>property was only exposed from .NET 9 and is not available in older versions of .NET. We can specify the value for</code>Capacity<code>in the constructor:</code>Dictionary&#x3C;int, int> dict = new Dictionary&#x3C;int, int>(5);`, which will create an underlying container of size 7. <strong>Why size 7?</strong> Initially, I was puzzled too, so I checked the source code of the Dictionary implementation.</p>\n<p>The size is 7 because .NET uses a <a href=\"https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/Collections/HashHelpers.cs#L31\">prime array</a>, and the code selects the smallest prime number from the array that is larger than the given capacity. Here is the prime array for reference:</p>\n<div class=\"remark-highlight\"><pre class=\"language-C\"><code class=\"language-C\">internal static ReadOnlySpan&#x26;lt;int&#x26;gt; Primes =&#x26;gt;\r\n    [\r\n        3, 7, 11, 17, 23, 29, 37, 47, 59, 71, 89, 107, 131, 163, 197, 239, 293, 353, 431, 521, 631, 761, 919,\r\n        1103, 1327, 1597, 1931, 2333, 2801, 3371, 4049, 4861, 5839, 7013, 8419, 10103, 12143, 14591,\r\n        17519, 21023, 25229, 30293, 36353, 43627, 52361, 62851, 75431, 90523, 108631, 130363, 156437,\r\n        187751, 225307, 270371, 324449, 389357, 467237, 560689, 672827, 807403, 968897, 1162687, 1395263,\r\n        1674319, 2009191, 2411033, 2893249, 3471899, 4166287, 4999559, 5999471, 7199369\r\n    ];</code></pre></div>\n<p>Now, with the size being 7, when we insert the 8th item into the <code>Dictionary</code>, .NET needs to resize the underlying container. For resizing, .NET first computes twice the current count and then finds the first prime number from the array that is larger than this value. In this example, it is 7 * 2 = 14, and the next prime in the list is 17. Therefore, after inserting the 8th item, the capacity of the dictionary will be 17.</p>\n<p>Also, if you know the size of the data in advance, specifying the capacity can provide a minor performance boost. Please see the benchmark results below for <code>Dictionary</code> insertion.</p>\n<p><img src=\"/images/Benchmark.PNG\" alt=\"\"><em>Gist: Benchmark results for Dictionary insert</em></p>\n<p><code>HashSet</code> and <code>OrderedDictionary</code> also behave in the same way with respect to capacity and resizing.</p>\n<p>For <code>Stack&#x3C;T></code>,<code> Queue&#x3C;T></code>, <code>SortedList&#x3C;TKey, TValue></code>, and <code>List&#x3C;T></code>, resizing is not based on the prime array. In these cases, the container is created with the given capacity in the constructor, and for resizing, the size is simply doubled. Consider the example: <code>Stack&#x3C;int> ints = new Stack&#x3C;int>(5);</code>. After pushing the 6th item, the size is doubled to 10.</p>\n<p><code>PriorityQueue&#x3C;TElement, TPriority></code> works similarly to <code>Queue&#x3C;T></code> and <code>List&#x3C;T></code>, but the property Capacity is not yet exposed.</p>\n<h2>Final Note</h2>\n<p>Understanding the inner workings of collections in C# can greatly enhance your ability to write efficient and effective code. As we've seen, the <code>Dictionary&#x3C;TKey, TValue></code> class in .NET 9 has some interesting behaviors, particularly with how it handles capacity and resizing. By leveraging the prime number array for sizing, .NET ensures that the hash table's performance remains optimal.</p>\n<p>Remember that specifying the initial capacity can lead to performance gains, especially when the size of the dataset is known beforehand. This is because it minimizes the number of resizes that need to occur as the collection grows.</p>\n<p>While <code>Dictionary&#x3C;TKey, TValue></code>, <code>HashSet&#x3C;T></code>, and <code>OrderedDictionary</code> use prime numbers to determine their capacities, other collections like <code>Stack&#x3C;T></code>, <code>Queue&#x3C;T></code>, <code>SortedList&#x3C;TKey, TValue></code>, and <code>List&#x3C;T></code> follow a simpler doubling strategy. This knowledge allows you to predict and control the memory usage and performance characteristics of your collections more accurately.</p>\n<p>Happy coding!</p>\n"},"__N_SSG":true}